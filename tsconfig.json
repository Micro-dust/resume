{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es5",
    "outDir": "lib",
    "declaration": true,
    "importHelpers": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "lib": ["esnext", "dom"],
    "jsx": "react",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
package csv;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LogToCsvExtractor {

    public static void main(String[] args) {
        // 假设日志文件都放在这个文件夹里
        String folderPath = "D:/logs";  // 示例路径，换成你实际的文件夹
        File folder = new File(folderPath);

        if (!folder.isDirectory()) {
            System.err.println("指定的路径不是文件夹！");
            return;
        }

        // 获取文件夹中所有后缀为 .log 的文件
        File[] logFiles = folder.listFiles(pathname ->
            pathname.isFile() && pathname.getName().endsWith(".log"));

        if (logFiles == null || logFiles.length == 0) {
            System.out.println("文件夹下没有找到任何 .log 文件。");
            return;
        }

        for (File logFile : logFiles) {
            // 构造输出 CSV 文件名
            String csvFileName = logFile.getName().replaceAll("\\.log$", "") + ".csv";
            File csvOutput = new File(folder, csvFileName);

            // 注意：Java 8 里没有 FileReader(File, Charset)，改用 InputStreamReader 来指定编码
            try (
                BufferedReader reader = new BufferedReader(
                    new InputStreamReader(
                        new FileInputStream(logFile),
                        StandardCharsets.UTF_8
                    )
                );
                BufferedWriter writer = new BufferedWriter(
                    new OutputStreamWriter(
                        new FileOutputStream(csvOutput),
                        StandardCharsets.UTF_8
                    )
                )
            ) {
                System.out.println("处理文件：" + logFile.getAbsolutePath());

                String line;
                boolean isFirstLine = true;
                while ((line = reader.readLine()) != null) {
                    // 跳过第一行
                    if (isFirstLine) {
                        isFirstLine = false;
                        continue;
                    }

                    // 提取【第 45 个“字节”开始到空白字符之前】的内容
                    String extractedPart = extractPart(line, 45);

                    // 提取行中方括号 [...] 内的内容（仅取第一个）
                    String bracketContent = extractBracketContent(line);

                    // 写入 CSV：每行用逗号分隔两个字段
                    if (extractedPart != null && bracketContent != null) {
                        writer.write(extractedPart + "," + bracketContent);
                        writer.newLine();
                    } else if (extractedPart != null) {
                        writer.write(extractedPart);
                        writer.newLine();
                    } else if (bracketContent != null) {
                        writer.write(bracketContent);
                        writer.newLine();
                    }
                }

                System.out.println("已生成 CSV 文件：" + csvOutput.getAbsolutePath());

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 按“半角=1，全角=2”的规则，从字符串中截取
     * 第 startByte 个“宽度”起，到空白字符(空格、制表符等)之前的内容。
     * 
     * @param line      原始行
     * @param startByte 第几“字节”（这里指自定义的半角=1、全角=2 的计数）
     * @return          截取得到的子串，若无法截取则返回 null
     */
    private static String extractPart(String line, int startByte) {
        if (line == null || line.isEmpty()) {
            return null;
        }
        // 先找到真正的起始字符索引
        int startIndex = getCharIndexAtByteWidth(line, startByte);
        if (startIndex < 0 || startIndex >= line.length()) {
            // 表示这行连“45字节”的长度都没达到
            return null;
        }

        // 从 startIndex 开始往后找到空白字符的位置
        int endIndex = startIndex;
        while (endIndex < line.length()) {
            char c = line.charAt(endIndex);
            if (Character.isWhitespace(c)) {
                break;
            }
            endIndex++;
        }

        // 截取
        return line.substring(startIndex, endIndex);
    }

    /**
     * 返回字符串中，对应“第 byteWidth 个宽度”所在的字符索引。
     * 若没到那么长就返回 -1。
     */
    private static int getCharIndexAtByteWidth(String line, int byteWidth) {
        int accumulatedWidth = 0;
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            // 判断此字符是“半角”还是“全角”
            if (isHalfWidth(c)) {
                accumulatedWidth += 1;
            } else {
                accumulatedWidth += 2;
            }

            if (accumulatedWidth == byteWidth) {
                // 如果想“从第 45 字节后面那个位置开始截取”，就返回 i+1。
                return i + 1; 
            } else if (accumulatedWidth > byteWidth) {
                // 已经超过了 45，就把当前字符看作第 45 宽度的落点
                return i;
            }
        }
        return -1; // 整行都没数到 45 宽度
    }

    /**
     * 简单判定是否为“半角字符”
     * 这里偷懒的做法：如果是 ASCII 范围就当半角，否则当全角。
     * 如果需要更精细的区分规则（如 \uFF00-\uFFEF 等），可自行扩展。
     */
    private static boolean isHalfWidth(char c) {
        return c >= 0x00 && c < 0x7F;
    }

    /**
     * 提取行中第一个方括号 [...] 中的内容
     * 若找不到或匹配不到则返回 null
     */
    private static String extractBracketContent(String line) {
        // 正则匹配中括号里的内容：\\[(.*?)\\]
        Pattern pattern = Pattern.compile("\\[(.*?)\\]");
        Matcher matcher = pattern.matcher(line);
        if (matcher.find()) {
            return matcher.group(1); // 拿到第一个中括号内的内容
        }
        return null;
    }
}
